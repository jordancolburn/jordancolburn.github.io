<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Slalom Skiing - Brooke's Fun Zone</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #1a1a2e;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .back-link {
      position: fixed;
      top: 1rem;
      left: 1rem;
      color: #fff;
      text-decoration: none;
      font-size: 1.1rem;
      opacity: 0.8;
      z-index: 100;
      transition: opacity 0.2s;
    }

    .back-link:hover { opacity: 1; }

    canvas {
      display: block;
      background: #e8f4f8;
    }

    .hud {
      position: fixed;
      top: 1rem;
      right: 1rem;
      color: #fff;
      font-size: 1.2rem;
      font-weight: bold;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
      z-index: 100;
      text-align: right;
    }

    .hud div { margin-bottom: 0.3rem; }

    .speed-bar-container {
      position: fixed;
      bottom: 1.5rem;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 16px;
      background: rgba(0,0,0,0.4);
      border-radius: 8px;
      overflow: hidden;
      z-index: 100;
      border: 2px solid rgba(255,255,255,0.3);
    }

    .speed-bar {
      height: 100%;
      background: linear-gradient(90deg, #4ecdc4, #ffe44d, #ff6b6b);
      border-radius: 6px;
      transition: width 0.1s;
    }

    .speed-label {
      position: fixed;
      bottom: 3rem;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font-size: 0.85rem;
      font-weight: 600;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      z-index: 100;
    }

    #startScreen, #gameOverScreen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(20, 20, 50, 0.92);
      z-index: 200;
      color: #fff;
    }

    #startScreen h1, #gameOverScreen h1 {
      font-size: 3rem;
      margin-bottom: 0.5rem;
      text-shadow: 2px 2px 6px rgba(0,0,0,0.3);
    }

    #startScreen .subtitle {
      font-size: 1.2rem;
      opacity: 0.8;
      margin-bottom: 2rem;
    }

    .controls-info {
      background: rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 1.5rem 2rem;
      margin-bottom: 2rem;
      text-align: left;
      font-size: 1rem;
      line-height: 1.8;
    }

    .controls-info kbd {
      background: rgba(255,255,255,0.2);
      border-radius: 6px;
      padding: 0.2rem 0.6rem;
      font-family: inherit;
      font-weight: bold;
    }

    .btn {
      padding: 1rem 3rem;
      font-size: 1.3rem;
      font-weight: bold;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      color: #fff;
      background: linear-gradient(135deg, #4ecdc4, #44a08d);
      box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(78, 205, 196, 0.6);
    }

    #gameOverScreen .stats {
      margin: 1.5rem 0;
      font-size: 1.2rem;
      line-height: 2;
    }

    #gameOverScreen .final-score {
      font-size: 2.5rem;
      font-weight: bold;
      color: #ffe44d;
      margin: 0.5rem 0;
    }

    .hidden { display: none !important; }
  </style>
</head>
<body>
  <a href="/kids/brooke/" class="back-link">&larr; Back</a>

  <div class="hud" id="hud">
    <div>Distance: <span id="distanceDisplay">0</span>m</div>
    <div>Gates: <span id="gatesDisplay">0</span></div>
    <div>Missed: <span id="missedDisplay">0</span></div>
  </div>

  <div class="speed-label">Speed</div>
  <div class="speed-bar-container">
    <div class="speed-bar" id="speedBar"></div>
  </div>

  <canvas id="gameCanvas"></canvas>

  <div id="startScreen">
    <h1>&#x26F7; Slalom Skiing</h1>
    <p class="subtitle">Olympic Slalom Challenge</p>
    <div class="controls-info">
      <kbd>&larr;</kbd> / <kbd>&rarr;</kbd> &mdash; Steer left / right<br>
      <kbd>&uarr;</kbd> &mdash; Crouch (tuck for speed)<br>
      <kbd>&darr;</kbd> &mdash; Brake (slow down)
    </div>
    <button class="btn" id="startBtn">Start Race</button>
  </div>

  <div id="gameOverScreen" class="hidden">
    <h1>&#x1F3BF; Run Complete!</h1>
    <div class="stats">
      <div>Distance: <span id="finalDistance">0</span>m</div>
      <div>Gates Cleared: <span id="finalGates">0</span></div>
      <div>Gates Missed: <span id="finalMissed">0</span></div>
    </div>
    <div class="final-score">Score: <span id="finalScore">0</span></div>
    <button class="btn" id="restartBtn">Try Again</button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- Resize ---
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- Game State ---
    const GATE_SPACING = 45;       // world units between gates
    const GATE_WIDTH_MIN = 5;
    const GATE_WIDTH_MAX = 9;
    const TRACK_WIDTH = 30;        // how far left/right the course wanders
    const MAX_MISSES = 3;

    let state;

    function initState() {
      state = {
        running: false,
        playerX: 0,           // lateral position (-1 to 1 normalized, world coords)
        playerSpeed: 0.22,    // forward speed (world units per frame)
        playerSteer: 0,       // current steering velocity
        distance: 0,          // how far down the hill
        gatesCleared: 0,
        gatesMissed: 0,
        gates: [],
        trees: [],
        keys: {},
        tuck: false,
        braking: false,
        particles: [],
        shakeTimer: 0,
        trail: [],
      };
      generateInitialGates();
      generateInitialTrees();
    }

    // --- Gate Generation ---
    function generateGate(zPos) {
      // Gates alternate blue/red and wander across the slope
      const side = (state.gates.length % 2 === 0) ? 'blue' : 'red';
      const gateWidth = GATE_WIDTH_MIN + Math.random() * (GATE_WIDTH_MAX - GATE_WIDTH_MIN);
      // Gate center wanders across slope — forces real turning
      const wanderRange = Math.min(TRACK_WIDTH * 0.55, 8 + state.distance * 0.004);
      const centerX = (Math.random() - 0.5) * 2 * wanderRange;

      return {
        z: zPos,
        x: centerX,
        width: gateWidth,
        side: side,
        passed: false,
        cleared: false,
      };
    }

    function generateInitialGates() {
      state.gates = [];
      for (let i = 1; i <= 30; i++) {
        state.gates.push(generateGate(i * GATE_SPACING));
      }
    }

    function generateInitialTrees() {
      state.trees = [];
      for (let i = 0; i < 80; i++) {
        const side = Math.random() < 0.5 ? -1 : 1;
        state.trees.push({
          z: Math.random() * 1200,
          x: side * (TRACK_WIDTH * 0.7 + Math.random() * 15),
        });
      }
    }

    // --- Input ---
    window.addEventListener('keydown', (e) => {
      if (!state) return;
      state.keys[e.key] = true;
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
      }
    });
    window.addEventListener('keyup', (e) => {
      if (!state) return;
      state.keys[e.key] = false;
    });

    // --- Touch Controls ---
    let touchStartX = 0;
    let touchActive = false;
    let touchCurrentX = 0;
    let touchTuck = false;

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchCurrentX = touch.clientX;
      touchActive = true;
      // Tap upper half = tuck, lower half = brake
      if (touch.clientY < canvas.height * 0.4) {
        touchTuck = true;
        if (state) state.keys['ArrowUp'] = true;
      } else if (touch.clientY > canvas.height * 0.7) {
        if (state) state.keys['ArrowDown'] = true;
      }
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!touchActive || !state) return;
      touchCurrentX = e.touches[0].clientX;
      const dx = touchCurrentX - touchStartX;
      const threshold = 20;
      state.keys['ArrowLeft'] = dx < -threshold;
      state.keys['ArrowRight'] = dx > threshold;
    });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      touchActive = false;
      if (state) {
        state.keys['ArrowLeft'] = false;
        state.keys['ArrowRight'] = false;
        state.keys['ArrowUp'] = false;
        state.keys['ArrowDown'] = false;
      }
      touchTuck = false;
    });

    // --- Perspective Projection ---
    const CAMERA_HEIGHT = 5;
    const CAMERA_BEHIND = 2;       // camera slightly behind skier
    const FOV_FACTOR = 160;        // higher = wider FOV
    const HORIZON_Y = 0.18;        // where horizon sits on screen (0=top) — low = more downhill feel

    function projectPoint(worldX, worldZ) {
      const relZ = worldZ - state.distance + CAMERA_BEHIND;
      if (relZ <= 0.5) return null;

      const scale = FOV_FACTOR / relZ;
      const screenX = canvas.width / 2 + (worldX - state.playerX) * scale;
      const horizonPx = canvas.height * HORIZON_Y;
      const screenY = horizonPx + (CAMERA_HEIGHT * scale);

      return { x: screenX, y: screenY, scale: scale };
    }

    // --- Rendering ---
    function drawSky() {
      const grad = ctx.createLinearGradient(0, 0, 0, canvas.height * HORIZON_Y);
      grad.addColorStop(0, '#87CEEB');
      grad.addColorStop(0.7, '#b8e0f0');
      grad.addColorStop(1, '#dceef5');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height * HORIZON_Y + 2);

      // Mountains
      const horizonY = canvas.height * HORIZON_Y;
      ctx.fillStyle = '#c8d8e8';
      ctx.beginPath();
      ctx.moveTo(0, horizonY);
      for (let x = 0; x <= canvas.width; x += 60) {
        const peakH = 20 + Math.sin(x * 0.01 + 1) * 30 + Math.cos(x * 0.023) * 20;
        ctx.lineTo(x, horizonY - peakH);
      }
      ctx.lineTo(canvas.width, horizonY);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = '#d8e8f0';
      ctx.beginPath();
      ctx.moveTo(0, horizonY);
      for (let x = 0; x <= canvas.width; x += 40) {
        const peakH = 10 + Math.sin(x * 0.015 + 3) * 20 + Math.cos(x * 0.03 + 1) * 15;
        ctx.lineTo(x, horizonY - peakH);
      }
      ctx.lineTo(canvas.width, horizonY);
      ctx.closePath();
      ctx.fill();
    }

    function drawSnowGround() {
      const horizonY = canvas.height * HORIZON_Y;
      // Gradient goes brighter at horizon (distance) to slightly shadowed near camera (closer = steeper slope feel)
      const grad = ctx.createLinearGradient(0, horizonY, 0, canvas.height);
      grad.addColorStop(0, '#edf3f8');
      grad.addColorStop(0.2, '#e4ecf4');
      grad.addColorStop(0.6, '#dae2ec');
      grad.addColorStop(1, '#cdd6e0');
      ctx.fillStyle = grad;
      ctx.fillRect(0, horizonY, canvas.width, canvas.height - horizonY);

      // Horizontal depth lines
      for (let z = 5; z < 300; z += 8) {
        const p = projectPoint(0, state.distance + z);
        if (!p || p.y < horizonY || p.y > canvas.height) continue;
        const alpha = Math.max(0, 0.12 - z * 0.0004);
        ctx.strokeStyle = `rgba(180, 200, 220, ${alpha})`;
        ctx.lineWidth = Math.max(0.5, p.scale * 0.05);
        ctx.beginPath();
        ctx.moveTo(0, p.y);
        ctx.lineTo(canvas.width, p.y);
        ctx.stroke();
      }

      // Slope shadow near bottom (ground rushing under you)
      const slopeShade = ctx.createLinearGradient(0, canvas.height - 80, 0, canvas.height);
      slopeShade.addColorStop(0, 'rgba(0,0,0,0)');
      slopeShade.addColorStop(1, 'rgba(0,0,0,0.06)');
      ctx.fillStyle = slopeShade;
      ctx.fillRect(0, canvas.height - 80, canvas.width, 80);
    }

    function drawTree(tree) {
      const p = projectPoint(tree.x, tree.z);
      if (!p || p.y < canvas.height * HORIZON_Y) return;

      const treeH = p.scale * 3;
      const trunkW = p.scale * 0.3;
      const leafW = p.scale * 1.5;

      if (treeH < 2) return;

      // Trunk
      ctx.fillStyle = '#6b4226';
      ctx.fillRect(p.x - trunkW / 2, p.y - treeH * 0.4, trunkW, treeH * 0.4);

      // Foliage (triangle layers)
      ctx.fillStyle = '#2d5a27';
      for (let i = 0; i < 3; i++) {
        const layerY = p.y - treeH * 0.3 - i * treeH * 0.25;
        const layerW = leafW * (1 - i * 0.2);
        ctx.beginPath();
        ctx.moveTo(p.x, layerY - treeH * 0.3);
        ctx.lineTo(p.x - layerW / 2, layerY);
        ctx.lineTo(p.x + layerW / 2, layerY);
        ctx.closePath();
        ctx.fill();
      }

      // Snow on top
      ctx.fillStyle = '#fff';
      for (let i = 0; i < 3; i++) {
        const layerY = p.y - treeH * 0.3 - i * treeH * 0.25;
        const layerW = leafW * (1 - i * 0.2) * 0.6;
        ctx.beginPath();
        ctx.moveTo(p.x, layerY - treeH * 0.3);
        ctx.lineTo(p.x - layerW / 2, layerY - treeH * 0.12);
        ctx.lineTo(p.x + layerW / 2, layerY - treeH * 0.12);
        ctx.closePath();
        ctx.fill();
      }
    }

    function drawGate(gate) {
      const leftPoleX = gate.x - gate.width / 2;
      const rightPoleX = gate.x + gate.width / 2;

      const pLeft = projectPoint(leftPoleX, gate.z);
      const pRight = projectPoint(rightPoleX, gate.z);
      if (!pLeft || !pRight) return;

      const horizonY = canvas.height * HORIZON_Y;
      if (pLeft.y < horizonY && pRight.y < horizonY) return;

      const color = gate.side === 'blue' ? '#2196F3' : '#F44336';
      const colorLight = gate.side === 'blue' ? '#64B5F6' : '#EF9A9A';

      const poleHeight = pLeft.scale * 3;
      const poleWidth = Math.max(2, pLeft.scale * 0.25);

      if (poleHeight < 2) return;

      // Left pole
      ctx.fillStyle = color;
      ctx.fillRect(pLeft.x - poleWidth / 2, pLeft.y - poleHeight, poleWidth, poleHeight);
      // Right pole
      ctx.fillRect(pRight.x - poleWidth / 2, pRight.y - poleHeight, poleWidth, poleHeight);

      // Banner between poles
      const bannerY = Math.min(pLeft.y, pRight.y) - poleHeight * 0.75;
      const bannerH = poleHeight * 0.2;
      ctx.fillStyle = colorLight;
      ctx.globalAlpha = 0.6;
      ctx.fillRect(pLeft.x, bannerY, pRight.x - pLeft.x, bannerH);
      ctx.globalAlpha = 1;

      // Pole tops (circles)
      const topRadius = Math.max(2, poleWidth * 1.2);
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(pLeft.x, pLeft.y - poleHeight, topRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(pRight.x, pRight.y - poleHeight, topRadius, 0, Math.PI * 2);
      ctx.fill();

      // If missed, draw X
      if (gate.passed && !gate.cleared) {
        const midX = (pLeft.x + pRight.x) / 2;
        const midY = bannerY + bannerH / 2;
        const sz = Math.max(6, poleHeight * 0.3);
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.moveTo(midX - sz, midY - sz);
        ctx.lineTo(midX + sz, midY + sz);
        ctx.moveTo(midX + sz, midY - sz);
        ctx.lineTo(midX - sz, midY + sz);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }

    function drawSkier() {
      const cx = canvas.width / 2;
      const baseY = canvas.height * 0.88;
      const lean = state.playerSteer;
      const leanAngle = -lean * 0.35;
      const tuck = state.tuck;

      // Shadow — elongates when leaning
      ctx.fillStyle = 'rgba(0,0,0,0.12)';
      ctx.beginPath();
      ctx.ellipse(cx + lean * 8, baseY + 4, 22 + Math.abs(lean) * 6, 5, leanAngle * 0.3, 0, Math.PI * 2);
      ctx.fill();

      ctx.save();
      ctx.translate(cx, baseY);
      ctx.rotate(leanAngle);

      const s = tuck ? 0.75 : 1;  // scale factor for tuck crouch

      // --- Skis (rounded, tapered) ---
      const skiW = 4;
      const skiLen = 44;
      const skiSpread = 10;
      ctx.fillStyle = '#2c3e50';
      ctx.strokeStyle = '#e74c3c';
      ctx.lineWidth = 1;
      for (const side of [-1, 1]) {
        ctx.save();
        ctx.rotate(side * 0.03 - leanAngle * 0.2);
        const sx = side * skiSpread;
        // Ski body
        ctx.beginPath();
        ctx.moveTo(sx, -4);
        ctx.quadraticCurveTo(sx - skiW / 2, skiLen * 0.5, sx - 1, skiLen);
        ctx.quadraticCurveTo(sx, skiLen + 3, sx + 1, skiLen);
        ctx.quadraticCurveTo(sx + skiW / 2, skiLen * 0.5, sx, -4);
        ctx.fill();
        // Ski tip curl
        ctx.beginPath();
        ctx.moveTo(sx - 1, -4);
        ctx.quadraticCurveTo(sx, -9, sx + 1, -4);
        ctx.stroke();
        ctx.restore();
      }

      // --- Boots ---
      ctx.fillStyle = '#1a1a2e';
      for (const side of [-1, 1]) {
        ctx.beginPath();
        ctx.ellipse(side * skiSpread, 2, 5, 4, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      // --- Legs (curved lines, not rectangles) ---
      const kneeY = -14 * s;
      const hipY = -26 * s;
      ctx.strokeStyle = '#1a237e';
      ctx.lineWidth = 7;
      ctx.lineCap = 'round';
      for (const side of [-1, 1]) {
        ctx.beginPath();
        ctx.moveTo(side * skiSpread, 0);
        ctx.quadraticCurveTo(side * 7, kneeY, side * 5, hipY);
        ctx.stroke();
      }

      // --- Torso ---
      const shoulderY = hipY - 18 * s;
      ctx.fillStyle = '#e53935';
      ctx.beginPath();
      ctx.moveTo(-11, hipY);
      ctx.quadraticCurveTo(-13, (hipY + shoulderY) / 2, -10, shoulderY);
      ctx.lineTo(10, shoulderY);
      ctx.quadraticCurveTo(13, (hipY + shoulderY) / 2, 11, hipY);
      ctx.closePath();
      ctx.fill();
      // Race bib number
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(0, (hipY + shoulderY) / 2, 6, 5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#e53935';
      ctx.font = 'bold 8px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('7', 0, (hipY + shoulderY) / 2);

      // --- Arms + poles ---
      ctx.strokeStyle = '#e53935';
      ctx.lineWidth = 5;
      ctx.lineCap = 'round';
      const elbowOut = tuck ? 18 : 14;
      const handY = tuck ? shoulderY + 6 : hipY - 4;
      for (const side of [-1, 1]) {
        // Arm
        ctx.beginPath();
        ctx.moveTo(side * 9, shoulderY + 2);
        ctx.quadraticCurveTo(side * elbowOut, shoulderY + 8, side * (elbowOut - 2), handY);
        ctx.stroke();
        // Pole
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(side * (elbowOut - 2), handY);
        ctx.lineTo(side * (elbowOut + 10), 30 * s);
        ctx.stroke();
        // Pole basket
        ctx.beginPath();
        ctx.arc(side * (elbowOut + 10), 30 * s, 3, 0, Math.PI * 2);
        ctx.stroke();
        ctx.strokeStyle = '#e53935';
        ctx.lineWidth = 5;
      }

      // --- Head ---
      const headY = shoulderY - 10;
      // Helmet
      ctx.fillStyle = '#1565C0';
      ctx.beginPath();
      ctx.ellipse(0, headY, 8, 9, 0, 0, Math.PI * 2);
      ctx.fill();
      // Goggle strap
      ctx.fillStyle = '#0D47A1';
      ctx.fillRect(-9, headY - 1, 18, 3);
      // Goggles
      ctx.fillStyle = '#FF8F00';
      ctx.beginPath();
      ctx.ellipse(0, headY, 7, 4, 0, 0, Math.PI);
      ctx.fill();
      // Goggle shine
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.beginPath();
      ctx.ellipse(-2, headY + 1, 3, 2, -0.2, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();

      // Snow spray when turning
      if (Math.abs(state.playerSteer) > 0.15 && state.playerSpeed > 0.15) {
        const sprayDir = state.playerSteer > 0 ? -1 : 1;
        for (let i = 0; i < 3; i++) {
          state.particles.push({
            x: cx + sprayDir * (15 + Math.random() * 10),
            y: baseY + Math.random() * 10,
            vx: sprayDir * (1 + Math.random() * 3),
            vy: -(1 + Math.random() * 2),
            life: 15 + Math.random() * 10,
            maxLife: 25,
            size: 2 + Math.random() * 3,
          });
        }
      }
    }

    function drawParticles() {
      for (const p of state.particles) {
        const alpha = p.life / p.maxLife;
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawTrail() {
      if (state.trail.length < 2) return;
      for (let i = 1; i < state.trail.length; i++) {
        const t = state.trail[i];
        const p = projectPoint(t.x, t.z);
        if (!p || p.y < canvas.height * HORIZON_Y) continue;
        const alpha = i / state.trail.length * 0.3;
        ctx.fillStyle = `rgba(180, 195, 210, ${alpha})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, Math.max(1, p.scale * 0.15), 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // --- Update ---
    function update() {
      if (!state.running) return;

      // Steering - slow buildup for fine control
      const steerAccel = 0.018;
      const steerFriction = 0.94;
      const maxSteer = 0.7;

      if (state.keys['ArrowLeft']) {
        state.playerSteer -= steerAccel;
      }
      if (state.keys['ArrowRight']) {
        state.playerSteer += steerAccel;
      }

      // Friction on steering — high value means momentum carries, giving analog feel
      state.playerSteer *= steerFriction;
      state.playerSteer = Math.max(-maxSteer, Math.min(maxSteer, state.playerSteer));

      // Apply steering to position
      state.playerX += state.playerSteer * 1.8;

      // G-force skid — hard turns cause lateral drift (slides outward)
      const skidForce = state.playerSteer * Math.abs(state.playerSteer) * 0.4;
      state.playerX += skidForce;

      // Speed: tuck increases, brake decreases, natural drag always present
      state.tuck = !!state.keys['ArrowUp'];
      state.braking = !!state.keys['ArrowDown'];

      const cruiseSpeed = 0.24;     // natural resting speed
      const maxSpeed = 0.42;
      const minSpeed = 0.14;

      // Always pull toward cruise speed
      state.playerSpeed += (cruiseSpeed - state.playerSpeed) * 0.03;

      // Tuck nudges faster, brake nudges slower
      if (state.tuck) {
        state.playerSpeed += 0.002;
      } else if (state.braking) {
        state.playerSpeed -= 0.003;
      }

      // Steering costs a tiny bit of speed
      state.playerSpeed -= Math.abs(state.playerSteer) * 0.003;

      state.playerSpeed = Math.max(minSpeed, Math.min(maxSpeed, state.playerSpeed));

      // Move forward
      state.distance += state.playerSpeed;

      // Trail
      if (state.trail.length === 0 || state.distance - state.trail[state.trail.length - 1].z > 2) {
        state.trail.push({ x: state.playerX, z: state.distance });
        if (state.trail.length > 80) state.trail.shift();
      }

      // Gate checking
      for (const gate of state.gates) {
        if (gate.passed) continue;
        if (state.distance > gate.z) {
          gate.passed = true;
          const leftEdge = gate.x - gate.width / 2;
          const rightEdge = gate.x + gate.width / 2;
          if (state.playerX >= leftEdge && state.playerX <= rightEdge) {
            gate.cleared = true;
            state.gatesCleared++;
            // Brief speed boost for clean gate
            state.playerSpeed = Math.min(0.42, state.playerSpeed + 0.01);
          } else {
            state.gatesMissed++;
            state.shakeTimer = 12;
            state.playerSpeed *= 0.85; // penalty
            if (state.gatesMissed >= MAX_MISSES) {
              endGame();
              return;
            }
          }
        }
      }

      // Generate new gates as needed
      const furthestGate = state.gates[state.gates.length - 1];
      if (furthestGate.z - state.distance < 500) {
        const newZ = furthestGate.z + GATE_SPACING;
        state.gates.push(generateGate(newZ));
      }

      // Remove old gates
      state.gates = state.gates.filter(g => g.z > state.distance - 20);

      // Recycle trees
      for (const tree of state.trees) {
        if (tree.z < state.distance - 20) {
          tree.z = state.distance + 200 + Math.random() * 1000;
          const side = Math.random() < 0.5 ? -1 : 1;
          tree.x = side * (TRACK_WIDTH * 0.7 + Math.random() * 15);
        }
      }

      // Update particles
      for (const p of state.particles) {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.15;
        p.life--;
      }
      state.particles = state.particles.filter(p => p.life > 0);

      // Shake timer
      if (state.shakeTimer > 0) state.shakeTimer--;

      // Update HUD
      document.getElementById('distanceDisplay').textContent = Math.floor(state.distance);
      document.getElementById('gatesDisplay').textContent = state.gatesCleared;
      document.getElementById('missedDisplay').textContent = state.gatesMissed;
      document.getElementById('speedBar').style.width = ((state.playerSpeed / 0.42) * 100) + '%';
    }

    // --- Render ---
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Screen shake
      if (state.shakeTimer > 0) {
        const shakeX = (Math.random() - 0.5) * state.shakeTimer * 0.8;
        const shakeY = (Math.random() - 0.5) * state.shakeTimer * 0.8;
        ctx.save();
        ctx.translate(shakeX, shakeY);
      }

      drawSky();
      drawSnowGround();

      // Collect all world objects sorted by Z (far to near)
      const objects = [];

      for (const tree of state.trees) {
        if (tree.z > state.distance && tree.z < state.distance + 300) {
          objects.push({ type: 'tree', z: tree.z, data: tree });
        }
      }

      for (const gate of state.gates) {
        if (gate.z > state.distance - 5 && gate.z < state.distance + 300) {
          objects.push({ type: 'gate', z: gate.z, data: gate });
        }
      }

      objects.sort((a, b) => b.z - a.z);

      drawTrail();

      for (const obj of objects) {
        if (obj.type === 'tree') drawTree(obj.data);
        else if (obj.type === 'gate') drawGate(obj.data);
      }

      drawSkier();
      drawParticles();

      if (state.shakeTimer > 0) {
        ctx.restore();
      }
    }

    // --- Game Loop ---
    let animId;

    function gameLoop() {
      update();
      render();
      animId = requestAnimationFrame(gameLoop);
    }

    // --- Game Flow ---
    function startGame() {
      initState();
      state.running = true;
      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');
      gameLoop();
    }

    function endGame() {
      state.running = false;
      cancelAnimationFrame(animId);

      const distance = Math.floor(state.distance);
      const gatesCleared = state.gatesCleared;
      const gatesMissed = state.gatesMissed;

      // Score: distance is the base, multiplied by gate accuracy
      const totalGates = gatesCleared + gatesMissed;
      const accuracy = totalGates > 0 ? gatesCleared / totalGates : 1;
      const score = Math.floor(distance * accuracy * (1 + gatesCleared * 0.1));

      document.getElementById('finalDistance').textContent = distance;
      document.getElementById('finalGates').textContent = gatesCleared;
      document.getElementById('finalMissed').textContent = gatesMissed;
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOverScreen').classList.remove('hidden');
    }

    // --- Button Handlers ---
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', startGame);

    // Also allow Enter/Space to start
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        const startVisible = !document.getElementById('startScreen').classList.contains('hidden');
        const overVisible = !document.getElementById('gameOverScreen').classList.contains('hidden');
        if (startVisible || overVisible) {
          e.preventDefault();
          startGame();
        }
      }
    });

    // Initial render of start background
    initState();
    render();
  </script>
</body>
</html>
